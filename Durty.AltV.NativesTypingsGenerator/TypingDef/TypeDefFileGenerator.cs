using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Durty.AltV.NativesTypingsGenerator.Models.Typing;

namespace Durty.AltV.NativesTypingsGenerator.TypingDef
{
    public class TypeDefFileGenerator
    {
        private readonly TypeDef _typeDefFile;
        private readonly bool _generateDocumentation;
        private readonly string _indent;

        public TypeDefFileGenerator(
            TypeDef typeDefFile,
            bool generateDocumentation = true,
            string indent = "\t")
        {
            _typeDefFile = typeDefFile;
            _generateDocumentation = generateDocumentation;
            _indent = indent;
        }

        public string Generate(bool generateHeader = true, List<string> customHeaderLines = null)
        {
            StringBuilder fileContent = new StringBuilder(string.Empty);
            if (generateHeader)
            {
                fileContent.Append($"// THIS FILE IS AUTOGENERATED by Durty AltV NativeDB Typings Generator\n// Generated {DateTime.Now.ToShortDateString()} {DateTime.Now.ToShortTimeString()}\n");
                if (customHeaderLines != null)
                {
                    foreach (var customHeaderLine in customHeaderLines)
                    {
                        fileContent.Append($"//{customHeaderLine}\n");
                    }
                }
                fileContent.Append("\n");
            }

            foreach (TypeDefModule typeDefModule in _typeDefFile.Modules)
            {
                fileContent.Append(GenerateModule(typeDefModule));
                fileContent.Append("\n");
            }

            return fileContent.ToString();
        }

        private StringBuilder GenerateInterface(TypeDefInterface typeDefInterface)
        {
            StringBuilder result = new StringBuilder($"{_indent}interface {typeDefInterface.Name} {{\n");
            result = typeDefInterface.Properties.Aggregate(result, (current, property) => current.Append($"{_indent}{_indent}{property.Name}: {property.Type};\n"));
            result.Append($"{_indent}}}");
            return result;
        }

        private string GenerateType(TypeDefType typeDefType)
        {
            return $"{_indent}type {typeDefType.Name} = {typeDefType.TypeDefinition};";
        }

        private StringBuilder GenerateModule(TypeDefModule typeDefModule)
        {
            StringBuilder result = new StringBuilder(string.Empty);
            result.Append($"declare module \"{typeDefModule.Name}\" {{\n");
            result.Append(typeDefModule.Interfaces.Aggregate(new StringBuilder(), (current, typeDef) => current.Append($"{GenerateInterface(typeDef)}\n")));
            result.Append("\n");
            result.Append(typeDefModule.Types.Aggregate(new StringBuilder(), (current, typeDef) => current.Append($"{GenerateType(typeDef)}\n")));
            result.Append("\n");
            result.Append(typeDefModule.Functions.Aggregate(result, (current, typeDef) => current.Append($"{GenerateFunction(typeDef)}\n")));
            result.Length--;
            result.Append("}");
            return result;
        }

        private StringBuilder GenerateFunction(TypeDefFunction typeDefFunction)
        {
            StringBuilder result = new StringBuilder(string.Empty);
            if (_generateDocumentation)
            {
                result.Append(GenerateFunctionDocumentation(typeDefFunction));
            }
            result.Append($"{_indent}export function {typeDefFunction.Name}(");
            foreach (var parameter in typeDefFunction.Parameters)
            {
                result.Append($"{parameter.Name}: {parameter.Type}");
                if (typeDefFunction.Parameters.Last() != parameter)
                {
                    result.Append(", ");
                }
            }
            result.Append($"): {typeDefFunction.ReturnType.Name};\n");

            return result;
        }

        private StringBuilder GenerateFunctionDocumentation(TypeDefFunction typeDefFunction)
        {
            //When no docs exist
            if (string.IsNullOrEmpty(typeDefFunction.Description) && typeDefFunction.Parameters.All(p => string.IsNullOrEmpty(p.Description) && string.IsNullOrEmpty(typeDefFunction.ReturnType.Description)))
                return new StringBuilder(string.Empty);

            StringBuilder result = new StringBuilder($"{_indent}/**\n");
            if (!string.IsNullOrEmpty(typeDefFunction.Description))
            {
                string[] descriptionLines = typeDefFunction.Description.Split("\n");
                foreach (string descriptionLine in descriptionLines)
                {
                    string sanitizedDescriptionLine = descriptionLine.Replace("/*", string.Empty).Replace("*/", string.Empty).Trim();
                    result.Append($"{_indent}* {sanitizedDescriptionLine}\n");
                }
            }
            //Add @remarks in the future?
            foreach (var parameter in typeDefFunction.Parameters)
            {
                if (!string.IsNullOrEmpty(parameter.Description))
                {
                    result.Append($"{_indent}* @param {parameter.Name} {parameter.Description}\n");
                }
            }
            if (!string.IsNullOrEmpty(typeDefFunction.ReturnType.Description))
            {
                result.Append($"{_indent}* @returns {typeDefFunction.ReturnType.Description}\n");
            }
            result.Append($"{_indent}*/\n");
            return result;
        }
    }
}
